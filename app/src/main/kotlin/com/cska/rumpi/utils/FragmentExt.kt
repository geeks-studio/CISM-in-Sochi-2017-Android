@file:Suppress("UNCHECKED_CAST")

package stdlib.kotlin.ext

import android.app.Activity
import android.content.Intent
import android.content.res.ColorStateList
import android.os.Bundle
import android.os.Parcelable
import android.support.annotation.ColorRes
import android.support.annotation.DimenRes
import android.support.annotation.StringRes
import android.support.v4.app.Fragment
import android.util.SparseArray
import com.cska.rumpi.utils.getColorCompat
import com.cska.rumpi.utils.getColorStateListCompat
import com.cska.rumpi.utils.getDimensionCompat
import com.cska.rumpi.utils.getDimensionPixelOffsetCompat
import com.cska.rumpi.utils.getDimensionPixelSizeCompat
import com.cska.rumpi.utils.hasSoftwareNavBar
import com.cska.rumpi.utils.hideKeyboard
import com.cska.rumpi.utils.navBarHeight
import com.cska.rumpi.utils.statusBarHeight
import java.io.Serializable
import java.util.ArrayList

///////////////////////////////////////////////////////////////////////////
// Hardware stuff
///////////////////////////////////////////////////////////////////////////

val Fragment.hasSoftwareNavBar: Boolean
    get() = activity.hasSoftwareNavBar

val Fragment.statusBarHeight: Int
    get() = activity.statusBarHeight

val Fragment.navBarHeight: Int
    get() = activity.navBarHeight

fun Fragment.hideKeyboard() {
    view?.hideKeyboard()
}


///////////////////////////////////////////////////////////////////////////
// Activity stuff
///////////////////////////////////////////////////////////////////////////

val Fragment.RESULT_OK: Int
    get() = Activity.RESULT_OK

val Fragment.RESULT_CANCELED: Int
    get() = Activity.RESULT_CANCELED

val Fragment.RESULT_FIRST_USER: Int
    get() = Activity.RESULT_FIRST_USER

fun Fragment.setTitle(@StringRes titleResId: Int) {
    activity?.setTitle(titleResId)
}

fun Fragment.setTitle(title: String?) {
    activity?.title = title
}

fun Fragment.invalidateOptionsMenu() {
    activity?.supportInvalidateOptionsMenu()
}

fun Fragment.setResult(resultCode: Int, data: Intent? = null) {
    activity?.setResult(resultCode, data)
}

fun Fragment.finish(): Unit {
    activity?.finish()
}


///////////////////////////////////////////////////////////////////////////
// Resources stuff
///////////////////////////////////////////////////////////////////////////

fun Fragment.getColorCompat(@ColorRes colorResId: Int): Int =
        context.getColorCompat(colorResId)

fun Fragment.getColorStateListCompat(@ColorRes colorResId: Int): ColorStateList =
        context.getColorStateListCompat(colorResId)

fun Fragment.getDimensionCompat(@DimenRes resId: Int): Float =
        context.getDimensionCompat(resId)

/**
 * Retrieve a dimensional for a particular resource ID for use
 * as a size in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for use as a size.  A size conversion involves
 * rounding the base value, and ensuring that a non-zero base value
 * is at least one pixel in size.
 *
 * @param id The desired resource identifier, as generated by the aapt
 *           tool. This integer encodes the package, type, and resource
 *           entry. The value 0 is an invalid identifier.
 *
 * @return Resource dimension value multiplied by the appropriate
 * metric and truncated to integer pixels.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @see #getDimension
 * @see #getDimensionPixelOffset
 */
fun Fragment.getDimensionPixelSizeCompat(@DimenRes resId: Int): Int =
        context.getDimensionPixelSizeCompat(resId)

/**
 * Retrieve a dimensional for a particular resource ID for use
 * as an offset in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for you.  An offset conversion involves simply
 * truncating the base value to an integer.
 *
 * @param id The desired resource identifier, as generated by the aapt
 *           tool. This integer encodes the package, type, and resource
 *           entry. The value 0 is an invalid identifier.
 *
 * @return Resource dimension value multiplied by the appropriate
 * metric and truncated to integer pixels.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @see #getDimension
 * @see #getDimensionPixelSize
 */
fun Fragment.getDimensionPixelOffsetCompat(@DimenRes resId: Int): Int =
        context.getDimensionPixelOffsetCompat(resId)


///////////////////////////////////////////////////////////////////////////
// Arguments
///////////////////////////////////////////////////////////////////////////

fun Fragment.booleanArgument(key: String, defValue: Boolean) = lazy { arguments?.getBoolean(key, defValue) ?: defValue }
fun Fragment.byteArgument(key: String, defValue: Byte) = lazy { arguments?.getByte(key, defValue) ?: defValue }
fun Fragment.shortArgument(key: String, defValue: Short) = lazy { arguments?.getShort(key, defValue) ?: defValue }
fun Fragment.intArgument(key: String, defValue: Int) = lazy { arguments?.getInt(key, defValue) ?: defValue }
fun Fragment.longArgument(key: String, defValue: Long) = lazy { arguments?.getLong(key, defValue) ?: defValue }

fun Fragment.floatArgument(key: String, defValue: Float) = lazy { arguments?.getFloat(key, defValue) ?: defValue }
fun Fragment.doubleArgument(key: String, defValue: Double) = lazy { arguments?.getDouble(key, defValue) ?: defValue }

fun Fragment.charArgument(key: String, defValue: Char) = lazy { arguments?.getChar(key, defValue) ?: defValue }
fun Fragment.charSequenceArgument(key: String, defValue: CharSequence? = null) = lazy { arguments?.getCharSequence(key, defValue) ?: defValue }
fun Fragment.stringArgument(key: String, defValue: String? = null) = lazy { arguments?.getString(key, defValue) ?: defValue }

fun <T : Parcelable> Fragment.parcelableArgument(key: String, defValue: T? = null): Lazy<T> = lazy { (arguments?.getParcelable<T>(key) ?: defValue) as T }
fun <T : Serializable> Fragment.serializableArgument(key: String, defValue: T? = null): Lazy<T> = lazy { (arguments.getSerializable(key) ?: defValue) as T }


fun Fragment.booleanArrayArgument(key: String, defValue: BooleanArray? = null) = lazy { arguments?.getBooleanArray(key) ?: defValue }
fun Fragment.byteArrayArgument(key: String, defValue: ByteArray) = lazy { arguments?.getByteArray(key) ?: defValue }
fun Fragment.shortArrayArgument(key: String, defValue: ShortArray? = null) = lazy { arguments?.getShortArray(key) ?: defValue }
fun Fragment.intArrayArgument(key: String, defValue: IntArray? = null) = lazy { arguments?.getIntArray(key) ?: defValue }
fun Fragment.longArrayArgument(key: String, defValue: LongArray? = null) = lazy { arguments?.getLongArray(key) ?: defValue }

fun Fragment.doubleArrayArgument(key: String, defValue: DoubleArray? = null) = lazy { arguments?.getDoubleArray(key) ?: defValue }
fun Fragment.floatArrayArgument(key: String, defValue: FloatArray? = null) = lazy { arguments?.getFloatArray(key) ?: defValue }

fun Fragment.charArrayArgument(key: String, defValue: CharArray? = null) = lazy { arguments?.getCharArray(key) ?: defValue }
fun Fragment.charSequenceArrayArgument(key: String, defValue: Array<CharSequence>? = null) = lazy { arguments?.getCharSequenceArray(key) ?: defValue }
fun Fragment.stringArrayArgument(key: String, defValue: Array<String>? = null) = lazy { arguments?.getStringArray(key) ?: defValue }

fun Fragment.parcelableArrayArgument(key: String, defValue: Array<Parcelable>? = null) = lazy { arguments?.getParcelableArray(key) ?: defValue }
fun <T : Parcelable> Fragment.parcelableArrayListArgument(key: String, defValue: ArrayList<T>? = null) = lazy { arguments?.getParcelableArrayList<T>(key) ?: defValue }
fun <T : Parcelable> Fragment.parcelableSparseArrayArgument(key: String, defValue: SparseArray<T>) = lazy { arguments?.getSparseParcelableArray<T>(key) ?: defValue }

fun Fragment.intArrayListArgument(key: String, defValue: ArrayList<Int>? = null) = lazy { arguments?.getIntegerArrayList(key) ?: defValue }
fun Fragment.charSequenceArrayListArgument(key: String, defValue: ArrayList<CharSequence>? = null) = lazy { arguments?.getCharSequenceArrayList(key) ?: defValue }
fun Fragment.stringArrayListArgument(key: String, defValue: ArrayList<String>? = null) = lazy { arguments?.getStringArrayList(key) ?: defValue }

fun Fragment.bundleArgument(key: String, defValue: Bundle? = null) = lazy { arguments?.getBundle(key) ?: defValue }
